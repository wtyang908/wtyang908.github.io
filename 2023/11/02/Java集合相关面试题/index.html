<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Java集合相关面试题 | wt小屋</title><meta name="author" content="我在守着黎明"><meta name="copyright" content="我在守着黎明"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="2 List相关面试题2.1 数组2.2 ArrayList源码分析分析ArrayList源码主要从三个方面去翻阅：成员变量，构造函数，关键方法  以下源码都来源于jdk1.8  2.2.1 成员变量  DEFAULT_CAPACITY &#x3D; 10;  默认初始的容量**(CAPACITY) EMPTY_ELEMENTDATA &#x3D; {}; 用于空实例的共享空数组实例 DEFAUL">
<meta property="og:type" content="article">
<meta property="og:title" content="Java集合相关面试题">
<meta property="og:url" content="http://example.com/2023/11/02/Java%E9%9B%86%E5%90%88%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/index.html">
<meta property="og:site_name" content="wt小屋">
<meta property="og:description" content="2 List相关面试题2.1 数组2.2 ArrayList源码分析分析ArrayList源码主要从三个方面去翻阅：成员变量，构造函数，关键方法  以下源码都来源于jdk1.8  2.2.1 成员变量  DEFAULT_CAPACITY &#x3D; 10;  默认初始的容量**(CAPACITY) EMPTY_ELEMENTDATA &#x3D; {}; 用于空实例的共享空数组实例 DEFAUL">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/avatar.jpg">
<meta property="article:published_time" content="2023-11-02T09:04:00.000Z">
<meta property="article:modified_time" content="2023-11-02T09:09:24.984Z">
<meta property="article:author" content="我在守着黎明">
<meta property="article:tag" content="集合">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/avatar.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2023/11/02/Java%E9%9B%86%E5%90%88%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: ,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Java集合相关面试题',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: false,
  postUpdate: '2023-11-02 17:09:24'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/loading.gif" data-original="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">2</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">1</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/shuoshuo/"><i class="fa-fw fa fa-comments-o"></i><span> 分享</span></a></li><li><a class="site-page child" href="/photos/"><i class="fa-fw fa fa-camera-retro"></i><span> 相册</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 影视</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/default_top_img.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="wt小屋"><span class="site-name">wt小屋</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/shuoshuo/"><i class="fa-fw fa fa-comments-o"></i><span> 分享</span></a></li><li><a class="site-page child" href="/photos/"><i class="fa-fw fa fa-camera-retro"></i><span> 相册</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 影视</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Java集合相关面试题</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-11-02T09:04:00.000Z" title="发表于 2023-11-02 17:04:00">2023-11-02</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-11-02T09:09:24.984Z" title="更新于 2023-11-02 17:09:24">2023-11-02</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/">面试八股</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">9.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>30分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Java集合相关面试题"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="2-List相关面试题"><a href="#2-List相关面试题" class="headerlink" title="2 List相关面试题"></a>2 List相关面试题</h2><h3 id="2-1-数组"><a href="#2-1-数组" class="headerlink" title="2.1 数组"></a>2.1 数组</h3><h3 id="2-2-ArrayList源码分析"><a href="#2-2-ArrayList源码分析" class="headerlink" title="2.2 ArrayList源码分析"></a>2.2 ArrayList源码分析</h3><p>分析ArrayList源码主要从三个方面去翻阅：成员变量，构造函数，关键方法</p>
<blockquote>
<p>以下源码都来源于jdk1.8</p>
</blockquote>
<h4 id="2-2-1-成员变量"><a href="#2-2-1-成员变量" class="headerlink" title="2.2.1 成员变量"></a>2.2.1 成员变量</h4><p><img src="/img/loading.gif" data-original="/Java%E9%9B%86%E5%90%88%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20230427192118259.png" alt="image-20230427192118259"></p>
<blockquote>
<p><em>DEFAULT_CAPACITY</em> &#x3D; 10;  默认初始的容量**(CAPACITY)</p>
<p><em>EMPTY_ELEMENTDATA</em> &#x3D; {}; 用于空实例的共享空数组实例</p>
<p><em>DEFAULTCAPACITY_EMPTY_ELEMENTDATA</em> &#x3D; {};用于默认大小的空实例的共享空数组实例</p>
<p>Object[] elementData;  存储元素的数组缓冲区</p>
<p>int size;     ArrayList的大小（它包含的元素数量）</p>
</blockquote>
<h4 id="2-2-2-构造方法"><a href="#2-2-2-构造方法" class="headerlink" title="2.2.2 构造方法"></a>2.2.2 构造方法</h4><p><img src="/img/loading.gif" data-original="/Java%E9%9B%86%E5%90%88%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20230427192154014.png" alt="image-20230427192154014"></p>
<blockquote>
<ul>
<li><p>第一个构造是带初始化容量的构造函数，可以按照指定的容量初始化数组</p>
</li>
<li><p>第二个是无参构造函数，默认创建一个空集合</p>
</li>
</ul>
</blockquote>
<p><img src="/img/loading.gif" data-original="/Java%E9%9B%86%E5%90%88%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20230427192200918.png" alt="image-20230427192200918"></p>
<blockquote>
<p>将collection对象转换成数组，然后将数组的地址的赋给elementData</p>
</blockquote>
<h4 id="2-2-3-ArrayList源码分析"><a href="#2-2-3-ArrayList源码分析" class="headerlink" title="2.2.3 ArrayList源码分析"></a>2.2.3 ArrayList源码分析</h4><p>添加数据的流程</p>
<p><img src="/img/loading.gif" data-original="/Java%E9%9B%86%E5%90%88%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20230427192644244.png" alt="image-20230427192644244"></p>
<p><strong>结论：</strong></p>
<ul>
<li>底层数据结构</li>
</ul>
<p>ArrayList底层是用动态的数组实现的</p>
<ul>
<li>初始容量</li>
</ul>
<p>ArrayList初始容量为0，当第一次添加数据的时候才会初始化容量为10</p>
<ul>
<li>扩容逻辑</li>
</ul>
<p>ArrayList在进行扩容的时候是原来容量的1.5倍，每次扩容都需要拷贝数组</p>
<ul>
<li><p>添加逻辑</p>
<ul>
<li><p>确保数组已使用长度（size）加1之后足够存下下一个数据 </p>
</li>
<li><p>计算数组的容量，如果当前数组已使用长度+1后的大于当前的数组长度，则调用grow方法扩容（原来的1.5倍）</p>
</li>
<li><p>确保新增的数据有地方存储之后，则将新元素添加到位于size的位置上。</p>
</li>
<li><p>返回添加成功布尔值。</p>
</li>
</ul>
</li>
</ul>
<h4 id="2-2-4-面试题-ArrayList-list-new-ArrayList-10-中的list扩容几次"><a href="#2-2-4-面试题-ArrayList-list-new-ArrayList-10-中的list扩容几次" class="headerlink" title="2.2.4 面试题-ArrayList list&#x3D;new ArrayList(10)中的list扩容几次"></a>2.2.4 面试题-ArrayList list&#x3D;new ArrayList(10)中的list扩容几次</h4><blockquote>
<p>难易程度：☆☆☆</p>
<p>出现频率：☆☆</p>
</blockquote>
<p><img src="/img/loading.gif" data-original="/Java%E9%9B%86%E5%90%88%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20230428185505677.png" alt="image-20230428185505677"></p>
<p>参考回答：</p>
<p> 该语句只是声明和实例了一个 ArrayList，指定了容量为 10，未扩容 </p>
<h4 id="2-2-4-面试题-如何实现数组和List之间的转换"><a href="#2-2-4-面试题-如何实现数组和List之间的转换" class="headerlink" title="2.2.4 面试题-如何实现数组和List之间的转换"></a>2.2.4 面试题-如何实现数组和List之间的转换</h4><blockquote>
<p>难易程度：☆☆☆</p>
<p>出现频率：☆☆</p>
</blockquote>
<p>如下代码：</p>
<p><img src="/img/loading.gif" data-original="/Java%E9%9B%86%E5%90%88%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20230428185600918.png" alt="image-20230428185600918"></p>
<p>参考回答：</p>
<ul>
<li><p>数组转List ，使用JDK中java.util.Arrays工具类的asList方法</p>
</li>
<li><p>List转数组，使用List的toArray方法。无参toArray方法返回 Object数组，传入初始化长度的数组对象，返回该对象数组</p>
</li>
</ul>
<p>面试官再问：</p>
<p>1，用Arrays.asList转List后，如果修改了数组内容，list受影响吗</p>
<p>2，List用toArray转数组后，如果修改了List内容，数组受影响吗</p>
<p><img src="/img/loading.gif" data-original="/Java%E9%9B%86%E5%90%88%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20230428185657791.png" alt="image-20230428185657791"></p>
<blockquote>
<p>数组转List受影响</p>
<p>List转数组不受影响</p>
</blockquote>
<p>再答：</p>
<p>1，用Arrays.asList转List后，如果修改了数组内容，list受影响吗</p>
<p>Arrays.asList转换list之后，如果修改了数组的内容，list会受影响，因为它的底层使用的Arrays类中的一个内部类ArrayList来构造的集合，在这个集合的构造器中，把我们传入的这个集合进行了包装而已，最终指向的都是同一个内存地址</p>
<p>2，List用toArray转数组后，如果修改了List内容，数组受影响吗</p>
<p>list用了toArray转数组后，如果修改了list内容，数组不会影响，当调用了toArray以后，在底层是它是进行了数组的拷贝，跟原来的元素就没啥关系了，所以即使list修改了以后，数组也不受影响</p>
<h3 id="2-3-链表"><a href="#2-3-链表" class="headerlink" title="2.3 链表"></a>2.3 链表</h3><h4 id="2-3-5-面试题-ArrayList和LinkedList的区别是什么？"><a href="#2-3-5-面试题-ArrayList和LinkedList的区别是什么？" class="headerlink" title="2.3.5 面试题-ArrayList和LinkedList的区别是什么？"></a>2.3.5 面试题-ArrayList和LinkedList的区别是什么？</h4><ul>
<li><p>底层数据结构</p>
<ul>
<li><p>ArrayList 是动态数组的数据结构实现</p>
</li>
<li><p>LinkedList 是双向链表的数据结构实现</p>
</li>
</ul>
</li>
<li><p>操作数据效率</p>
<ul>
<li>ArrayList按照下标查询的时间复杂度O(1)【内存是连续的，根据寻址公式】， LinkedList不支持下标查询</li>
<li>查找（未知索引）： ArrayList需要遍历，链表也需要链表，时间复杂度都是O(n)</li>
<li>新增和删除<ul>
<li>ArrayList尾部插入和删除，时间复杂度是O(1)；其他部分增删需要挪动数组，时间复杂度是O(n)</li>
<li>LinkedList头尾节点增删时间复杂度是O(1)，其他都需要遍历链表，时间复杂度是O(n)</li>
</ul>
</li>
</ul>
</li>
<li><p>内存空间占用</p>
<ul>
<li><p>ArrayList底层是数组，内存连续，节省内存</p>
</li>
<li><p>LinkedList 是双向链表需要存储数据，和两个指针，更占用内存</p>
</li>
</ul>
</li>
<li><p>线程安全</p>
<ul>
<li>ArrayList和LinkedList都不是线程安全的</li>
<li>如果需要保证线程安全，有两种方案：<ul>
<li>在方法内使用，局部变量则是线程安全的</li>
<li>使用线程安全的ArrayList和LinkedList</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="3-HashMap相关面试题"><a href="#3-HashMap相关面试题" class="headerlink" title="3 HashMap相关面试题"></a>3 HashMap相关面试题</h2><p><img src="/img/loading.gif" data-original="/Java%E9%9B%86%E5%90%88%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20230428194715016.png" alt="image-20230428194715016"></p>
<h3 id="3-1-二叉树"><a href="#3-1-二叉树" class="headerlink" title="3.1 二叉树"></a>3.1 二叉树</h3><h4 id="3-1-2-二叉搜索树"><a href="#3-1-2-二叉搜索树" class="headerlink" title="3.1.2 二叉搜索树"></a>3.1.2 二叉搜索树</h4><p>在二叉树中，比较常见的二叉树有：</p>
<ul>
<li><p>满二叉树</p>
</li>
<li><p>完全二叉树</p>
</li>
<li><p><strong>二叉搜索树</strong></p>
</li>
<li><p><strong>红黑树</strong></p>
</li>
</ul>
<p>我们重点讲解二叉搜索树和红黑树</p>
<p>（1）二叉搜索树概述</p>
<p>二叉搜索树(Binary Search Tree,BST)又名二叉查找树，有序二叉树或者排序二叉树，是二叉树中比较常用的一种类型</p>
<p>二叉查找树要求，在树中的任意一个节点，其左子树中的每个节点的值，都要小于这个节点的值，而右子树节点的值都大于这个节点的值</p>
<p><img src="/img/loading.gif" data-original="/Java%E9%9B%86%E5%90%88%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20230428195206422.png" alt="image-20230428195206422"></p>
<p>（2）二叉搜索树-时间复杂度分析</p>
<p>实际上由于二叉查找树的形态各异，时间复杂度也不尽相同，我画了几棵树我们来看一下插入，查找，删除的时间复杂度</p>
<p><img src="/img/loading.gif" data-original="/Java%E9%9B%86%E5%90%88%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20230428195341917.png" alt="image-20230428195341917"></p>
<p>插入，查找，删除的时间复杂度<strong>O(logn)</strong></p>
<p>极端情况下二叉搜索的时间复杂度</p>
<p><img src="/img/loading.gif" data-original="/Java%E9%9B%86%E5%90%88%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20230428195449799.png" alt="image-20230428195449799"></p>
<p>对于图中这种情况属于最坏的情况，二叉查找树已经退化成了链表，左右子树极度不平衡，此时查找的时间复杂度肯定是O(n)。</p>
<h4 id="3-1-3-红黑树"><a href="#3-1-3-红黑树" class="headerlink" title="3.1.3 红黑树"></a>3.1.3 红黑树</h4><p>（1）概述</p>
<p><strong>红黑树（Red Black Tree）</strong>：也是一种自平衡的二叉搜索树(BST)，之前叫做平衡二叉B树（Symmetric Binary B-Tree）</p>
<p><img src="/img/loading.gif" data-original="/Java%E9%9B%86%E5%90%88%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20230428195832724.png" alt="image-20230428195832724"></p>
<p>（2）红黑树的特质</p>
<p>性质1：节点要么是<strong>红色</strong>,要么是<strong>黑色</strong></p>
<p>性质2：根节点是<strong>黑色</strong></p>
<p>性质3：叶子节点都是黑色的空节点</p>
<p>性质4：红黑树中红色节点的子节点都是黑色</p>
<p>性质5：从任一节点到叶子节点的所有路径都包含相同数目的黑色节点</p>
<p><strong>在添加或删除节点的时候，如果不符合这些性质会发生旋转，以达到所有的性质，保证红黑树的平衡</strong></p>
<p>（3）红黑树的复杂度</p>
<ul>
<li><p>查找：</p>
<ul>
<li>红黑树也是一棵BST（二叉搜索树）树，查找操作的时间复杂度为：O(log n)</li>
</ul>
</li>
<li><p>添加：</p>
<ul>
<li>添加先要从根节点开始找到元素添加的位置，时间复杂度O(log n)</li>
<li>添加完成后涉及到复杂度为O(1)的旋转调整操作</li>
<li>故整体复杂度为：O(log n)</li>
</ul>
</li>
<li><p>删除：</p>
<ul>
<li>首先从根节点开始找到被删除元素的位置，时间复杂度O(log n)</li>
<li>删除完成后涉及到复杂度为O(1)的旋转调整操作</li>
<li>故整体复杂度为：O(log n)</li>
</ul>
</li>
</ul>
<h3 id="3-2-散列表"><a href="#3-2-散列表" class="headerlink" title="3.2 散列表"></a>3.2 散列表</h3><p>在HashMap中的最重要的一个数据结构就是散列表，在散列表中又使用到了红黑树和链表</p>
<h4 id="3-2-1-散列表（Hash-Table）概述"><a href="#3-2-1-散列表（Hash-Table）概述" class="headerlink" title="3.2.1 散列表（Hash Table）概述"></a>3.2.1 散列表（Hash Table）概述</h4><p>散列表(Hash Table)又名哈希表&#x2F;Hash表，是根据键（Key）直接访问在内存存储位置值（Value）的数据结构，它是由数组演化而来的，利用了数组支持按照下标进行随机访问数据的特性</p>
<p>举个例子：</p>
<p><img src="/img/loading.gif" data-original="/Java%E9%9B%86%E5%90%88%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20230428200919454.png" alt="image-20230428200919454"></p>
<p>假设有100个人参加马拉松，编号是1-100，如果要编程实现根据选手的编号迅速找到选手信息？</p>
<p>可以把选手信息存入数组中，选手编号就是数组的下标，数组的元素就是选手的信息。</p>
<p>当我们查询选手信息的时候，只需要根据选手的编号到数组中查询对应的元素就可以快速找到选手的信息，如下图：</p>
<p><img src="/img/loading.gif" data-original="/Java%E9%9B%86%E5%90%88%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20230428201000814.png" alt="image-20230428201000814"></p>
<p>现在需求升级了：</p>
<p>假设有100个人参加马拉松，不采用1-100的自然数对选手进行编号，编号有一定的规则比如：2023ZHBJ001，其中2023代表年份，ZH代表中国，BJ代表北京，001代表原来的编号，那此时的编号2023ZHBJ001不能直接作为数组的下标，此时应该如何实现呢？</p>
<p><img src="/img/loading.gif" data-original="/Java%E9%9B%86%E5%90%88%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20230428201321607.png" alt="image-20230428201321607"></p>
<p>我们目前是把选手的信息存入到数组中，不过选手的编号不能直接作为数组的下标，不过，可以把选手的选号进行转换，转换为数值就可以继续作为数组的下标了？</p>
<p>转换可以使用散列函数进行转换</p>
<h4 id="3-2-2-散列函数和散列冲突"><a href="#3-2-2-散列函数和散列冲突" class="headerlink" title="3.2.2 散列函数和散列冲突"></a>3.2.2 散列函数和散列冲突</h4><p>将键(key)映射为数组下标的函数叫做散列函数。可以表示为：hashValue &#x3D; hash(key)</p>
<p>散列函数的基本要求：</p>
<ul>
<li><p>散列函数计算得到的散列值必须是大于等于0的正整数，因为hashValue需要作为数组的下标。</p>
</li>
<li><p>如果key1&#x3D;&#x3D;key2，那么经过hash后得到的哈希值也必相同即：hash(key1) &#x3D;&#x3D; hash(key2）</p>
</li>
<li><p><strong>如果key1 !&#x3D; key2，那么经过hash后得到的哈希值也必不相同即：hash(key1) !&#x3D; hash(key2)</strong></p>
</li>
</ul>
<p>实际的情况下想找一个散列函数能够做到对于不同的key计算得到的散列值都不同几乎是不可能的，即便像著名的MD5,SHA等哈希算法也无法避免这一情况，这就是散列冲突(或者哈希冲突，哈希碰撞，<strong>就是指多个key映射到同一个数组下标位置</strong>)</p>
<p><img src="/img/loading.gif" data-original="/Java%E9%9B%86%E5%90%88%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20230428203219225.png" alt="image-20230428203219225"></p>
<h4 id="3-2-3-散列冲突-链表法（拉链）"><a href="#3-2-3-散列冲突-链表法（拉链）" class="headerlink" title="3.2.3 散列冲突-链表法（拉链）"></a>3.2.3 散列冲突-链表法（拉链）</h4><p>在散列表中，数组的每个下标位置我们可以称之为桶（bucket）或者槽（slot），每个桶(槽)会对应一条链表，所有散列值相同的元素我们都放到相同槽位对应的链表中。</p>
<p><img src="/img/loading.gif" data-original="/Java%E9%9B%86%E5%90%88%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20230428203437910.png" alt="image-20230428203437910"></p>
<p>简单就是，如果有多个key最终的hash值是一样的，就会存入数组的同一个下标中，下标中挂一个链表存入多个数据</p>
<h4 id="3-2-4-时间复杂度-散列表"><a href="#3-2-4-时间复杂度-散列表" class="headerlink" title="3.2.4 时间复杂度-散列表"></a>3.2.4 时间复杂度-散列表</h4><p>1，插入操作，通过散列函数计算出对应的散列槽位，将其插入到对应链表中即可，插入的时间复杂度是 O(1)</p>
<p><img src="/img/loading.gif" data-original="/Java%E9%9B%86%E5%90%88%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20230428203711269.png" alt="image-20230428203711269"></p>
<blockquote>
<p>通过计算就可以找到元素</p>
</blockquote>
<p>2，当查找、删除一个元素时，我们同样通过散列函数计算出对应的槽，然后遍历链表查找或者删除</p>
<ul>
<li><p>平均情况下基于链表法解决冲突时查询的时间复杂度是O(1)</p>
</li>
<li><p>散列表可能会退化为链表,查询的时间复杂度就从 O(1) 退化为 O(n)</p>
</li>
</ul>
<p><img src="/img/loading.gif" data-original="/Java%E9%9B%86%E5%90%88%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20230428203858903.png" alt="image-20230428203858903"></p>
<ul>
<li>将链表法中的链表改造为其他高效的动态数据结构，比如红黑树，查询的时间复杂度是 O(logn)</li>
</ul>
<p><img src="/img/loading.gif" data-original="/Java%E9%9B%86%E5%90%88%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20230428203924816.png" alt="image-20230428203924816"></p>
<p>将链表法中的链表改造红黑树还有一个非常重要的原因，可以防止DDos攻击</p>
<blockquote>
<p>DDos 攻击:</p>
<p>分布式拒绝服务攻击(英文意思是Distributed Denial of Service，简称DDoS）</p>
<p>指处于不同位置的多个攻击者同时向一个或数个目标发动攻击，或者一个攻击者控制了位于不同位置的多台机器并利用这些机器对受害者同时实施攻击。由于攻击的发出点是分布在不同地方的，这类攻击称为分布式拒绝服务攻击，其中的攻击者可以有多个</p>
</blockquote>
<h3 id="3-3-面试题-说一下HashMap的实现原理？"><a href="#3-3-面试题-说一下HashMap的实现原理？" class="headerlink" title="3.3 面试题-说一下HashMap的实现原理？"></a>3.3 面试题-说一下HashMap的实现原理？</h3><p>HashMap的数据结构： 底层使用hash表数据结构，即数组和链表或红黑树</p>
<ol>
<li><p>当我们往HashMap中put元素时，利用key的hashCode重新hash计算出当前对象的元素在数组中的下标 </p>
</li>
<li><p>存储时，如果出现hash值相同的key，此时有两种情况。</p>
</li>
</ol>
<p>  a. 如果key相同，则覆盖原始值；</p>
<p>  b. 如果key不同（出现冲突），则将当前的key-value放入链表或红黑树中 </p>
<ol start="3">
<li>获取时，直接找到hash值对应的下标，在进一步判断key是否相同，从而找到对应值。</li>
</ol>
<p><img src="/img/loading.gif" data-original="/Java%E9%9B%86%E5%90%88%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20230428204902016.png" alt="image-20230428204902016"></p>
<p>面试官追问：HashMap的jdk1.7和jdk1.8有什么区别</p>
<ul>
<li><p>JDK1.8之前采用的是拉链法。拉链法：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。</p>
</li>
<li><p>jdk1.8在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8） 时并且数组长度达到64时，将链表转化为红黑树，以减少搜索时间。扩容 resize( ) 时，红黑树拆分成的树的结点数小于等于临界值6个，则退化成链表</p>
</li>
</ul>
<h3 id="3-4-面试题-HashMap的put方法的具体流程"><a href="#3-4-面试题-HashMap的put方法的具体流程" class="headerlink" title="3.4 面试题-HashMap的put方法的具体流程"></a>3.4 面试题-HashMap的put方法的具体流程</h3><h4 id="3-4-1-hashMap常见属性"><a href="#3-4-1-hashMap常见属性" class="headerlink" title="3.4.1 hashMap常见属性"></a>3.4.1 hashMap常见属性</h4><p><img src="/img/loading.gif" data-original="/Java%E9%9B%86%E5%90%88%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20230428210404117.png" alt="image-20230428210404117"></p>
<h4 id="3-4-2-源码分析"><a href="#3-4-2-源码分析" class="headerlink" title="3.4.2 源码分析"></a>3.4.2 源码分析</h4><p><img src="/img/loading.gif" data-original="/Java%E9%9B%86%E5%90%88%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20230428210450744.png" alt="image-20230428210450744"></p>
<ul>
<li><p>HashMap是懒惰加载，在创建对象时并没有初始化数组</p>
</li>
<li><p>在无参的构造函数中，设置了默认的加载因子是0.75</p>
</li>
</ul>
<p>添加数据流程图</p>
<p><img src="/img/loading.gif" data-original="/Java%E9%9B%86%E5%90%88%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20230428210624847.png" alt="image-20230428210624847"></p>
<p>具体的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent,</span></span><br><span class="line"><span class="params">                   <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, i;</span><br><span class="line">    <span class="comment">//判断数组是否未初始化</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        <span class="comment">//如果未初始化，调用resize方法 进行初始化</span></span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">//通过 &amp; 运算求出该数据（key）的数组下标并判断该下标位置是否有数据</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)</span><br><span class="line">        <span class="comment">//如果没有，直接将数据放在该下标位置</span></span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">    <span class="comment">//该数组下标有数据的情况</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">//判断该位置数据的key和新来的数据是否一样</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="comment">//如果一样，证明为修改操作，该节点的数据赋值给e,后边会用到</span></span><br><span class="line">            e = p;</span><br><span class="line">        <span class="comment">//判断是不是红黑树</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            <span class="comment">//如果是红黑树的话，进行红黑树的操作</span></span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="built_in">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="comment">//新数据和当前数组既不相同，也不是红黑树节点，证明是链表</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//遍历链表</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="comment">//判断next节点，如果为空的话，证明遍历到链表尾部了</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//把新值放入链表尾部</span></span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">                    <span class="comment">//因为新插入了一条数据，所以判断链表长度是不是大于等于8</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        <span class="comment">//如果是，进行转换红黑树操作</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//判断链表当中有数据相同的值，如果一样，证明为修改操作</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">//把下一个节点赋值为当前节点</span></span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断e是否为空（e值为修改操作存放原数据的变量）</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            <span class="comment">//不为空的话证明是修改操作，取出老值</span></span><br><span class="line">            <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">            <span class="comment">//一定会执行  onlyIfAbsent传进来的是false</span></span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="literal">null</span>)</span><br><span class="line">                <span class="comment">//将新值赋值当前节点</span></span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="comment">//返回老值</span></span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//计数器，计算当前节点的修改次数</span></span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">//当前数组中的数据数量如果大于扩容阈值</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        <span class="comment">//进行扩容操作</span></span><br><span class="line">        resize();</span><br><span class="line">    <span class="comment">//空方法</span></span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="comment">//添加操作时 返回空值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>判断键值对数组table是否为空或为null，否则执行resize()进行扩容（初始化）</p>
</li>
<li><p>根据键值key计算hash值得到数组索引</p>
</li>
<li><p>判断table[i]&#x3D;&#x3D;null，条件成立，直接新建节点添加</p>
</li>
<li><p>如果table[i]&#x3D;&#x3D;null ,不成立</p>
<p>4.1 判断table[i]的首个元素是否和key一样，如果相同直接覆盖value</p>
<p>4.2 判断table[i] 是否为treeNode，即table[i] 是否是红黑树，如果是红黑树，则直接在树中插入键值对</p>
<p>4.3 遍历table[i]，链表的尾部插入数据，然后判断链表长度是否大于8，大于8的话把链表转换为红黑树，在红黑树中执行插入操 作，遍历过程中若发现key已经存在直接覆盖value</p>
</li>
<li><p>插入成功后，判断实际存在的键值对数量size是否超多了最大容量threshold（数组长度*0.75），如果超过，进行扩容。</p>
</li>
</ol>
<h3 id="3-5-面试题-讲一讲HashMap的扩容机制"><a href="#3-5-面试题-讲一讲HashMap的扩容机制" class="headerlink" title="3.5 面试题-讲一讲HashMap的扩容机制"></a>3.5 面试题-讲一讲HashMap的扩容机制</h3><p><img src="/img/loading.gif" data-original="/Java%E9%9B%86%E5%90%88%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20230428210844694.png" alt="image-20230428210844694"></p>
<p>扩容的流程：</p>
<p><img src="/img/loading.gif" data-original="/Java%E9%9B%86%E5%90%88%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20230428211031968.png" alt="image-20230428211031968"></p>
<p>源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//扩容、初始化数组</span></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    	<span class="comment">//如果当前数组为null的时候，把oldCap老数组容量设置为0</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">oldCap</span> <span class="operator">=</span> (oldTab == <span class="literal">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">        <span class="comment">//老的扩容阈值</span></span><br><span class="line">    	<span class="type">int</span> <span class="variable">oldThr</span> <span class="operator">=</span> threshold;</span><br><span class="line">        <span class="type">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//判断数组容量是否大于0，大于0说明数组已经初始化</span></span><br><span class="line">    	<span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//判断当前数组长度是否大于最大数组长度</span></span><br><span class="line">            <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">                <span class="comment">//如果是，将扩容阈值直接设置为int类型的最大数值并直接返回</span></span><br><span class="line">                threshold = Integer.MAX_VALUE;</span><br><span class="line">                <span class="keyword">return</span> oldTab;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果在最大长度范围内，则需要扩容  OldCap &lt;&lt; 1等价于oldCap*2</span></span><br><span class="line">            <span class="comment">//运算过后判断是不是最大值并且oldCap需要大于16</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                     oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">                newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold  等价于oldThr*2</span></span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="comment">//如果oldCap&lt;0，但是已经初始化了，像把元素删除完之后的情况，那么它的临界值肯定还存在，       			如果是首次初始化，它的临界值则为0</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">            newCap = oldThr;</span><br><span class="line">        <span class="comment">//数组未初始化的情况，将阈值和扩容因子都设置为默认值</span></span><br><span class="line">    	<span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">            newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">            newThr = (<span class="type">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="comment">//初始化容量小于16的时候，扩容阈值是没有赋值的</span></span><br><span class="line">        <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//创建阈值</span></span><br><span class="line">            <span class="type">float</span> <span class="variable">ft</span> <span class="operator">=</span> (<span class="type">float</span>)newCap * loadFactor;</span><br><span class="line">            <span class="comment">//判断新容量和新阈值是否大于最大容量</span></span><br><span class="line">            newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="type">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                      (<span class="type">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="comment">//计算出来的阈值赋值</span></span><br><span class="line">        threshold = newThr;</span><br><span class="line">        <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">        <span class="comment">//根据上边计算得出的容量 创建新的数组       </span></span><br><span class="line">    	Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>[newCap];</span><br><span class="line">    	<span class="comment">//赋值</span></span><br><span class="line">    	table = newTab;</span><br><span class="line">    	<span class="comment">//扩容操作，判断不为空证明不是初始化数组</span></span><br><span class="line">        <span class="keyword">if</span> (oldTab != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//遍历数组</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">                Node&lt;K,V&gt; e;</span><br><span class="line">                <span class="comment">//判断当前下标为j的数组如果不为空的话赋值个e，进行下一步操作</span></span><br><span class="line">                <span class="keyword">if</span> ((e = oldTab[j]) != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//将数组位置置空</span></span><br><span class="line">                    oldTab[j] = <span class="literal">null</span>;</span><br><span class="line">                    <span class="comment">//判断是否有下个节点</span></span><br><span class="line">                    <span class="keyword">if</span> (e.next == <span class="literal">null</span>)</span><br><span class="line">                        <span class="comment">//如果没有，就重新计算在新数组中的下标并放进去</span></span><br><span class="line">                        newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                   	<span class="comment">//有下个节点的情况，并且判断是否已经树化</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                        <span class="comment">//进行红黑树的操作</span></span><br><span class="line">                        ((TreeNode&lt;K,V&gt;)e).split(<span class="built_in">this</span>, newTab, j, oldCap);</span><br><span class="line">                    <span class="comment">//有下个节点的情况，并且没有树化（链表形式）</span></span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">//比如老数组容量是16，那下标就为0-15</span></span><br><span class="line">                        <span class="comment">//扩容操作*2，容量就变为32，下标为0-31</span></span><br><span class="line">                        <span class="comment">//低位：0-15，高位16-31</span></span><br><span class="line">                        <span class="comment">//定义了四个变量</span></span><br><span class="line">                        <span class="comment">//        低位头          低位尾</span></span><br><span class="line">                        Node&lt;K,V&gt; loHead = <span class="literal">null</span>, loTail = <span class="literal">null</span>;</span><br><span class="line">                        <span class="comment">//        高位头		   高位尾</span></span><br><span class="line">                        Node&lt;K,V&gt; hiHead = <span class="literal">null</span>, hiTail = <span class="literal">null</span>;</span><br><span class="line">                        <span class="comment">//下个节点</span></span><br><span class="line">                        Node&lt;K,V&gt; next;</span><br><span class="line">                        <span class="comment">//循环遍历</span></span><br><span class="line">                        <span class="keyword">do</span> &#123;</span><br><span class="line">                            <span class="comment">//取出next节点</span></span><br><span class="line">                            next = e.next;</span><br><span class="line">                            <span class="comment">//通过 与操作 计算得出结果为0</span></span><br><span class="line">                            <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                                <span class="comment">//如果低位尾为null，证明当前数组位置为空，没有任何数据</span></span><br><span class="line">                                <span class="keyword">if</span> (loTail == <span class="literal">null</span>)</span><br><span class="line">                                    <span class="comment">//将e值放入低位头</span></span><br><span class="line">                                    loHead = e;</span><br><span class="line">                                <span class="comment">//低位尾不为null，证明已经有数据了</span></span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    <span class="comment">//将数据放入next节点</span></span><br><span class="line">                                    loTail.next = e;</span><br><span class="line">                                <span class="comment">//记录低位尾数据</span></span><br><span class="line">                                loTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">//通过 与操作 计算得出结果不为0</span></span><br><span class="line">                            <span class="keyword">else</span> &#123;</span><br><span class="line">                                 <span class="comment">//如果高位尾为null，证明当前数组位置为空，没有任何数据</span></span><br><span class="line">                                <span class="keyword">if</span> (hiTail == <span class="literal">null</span>)</span><br><span class="line">                                    <span class="comment">//将e值放入高位头</span></span><br><span class="line">                                    hiHead = e;</span><br><span class="line">                                <span class="comment">//高位尾不为null，证明已经有数据了</span></span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    <span class="comment">//将数据放入next节点</span></span><br><span class="line">                                    hiTail.next = e;</span><br><span class="line">                               <span class="comment">//记录高位尾数据</span></span><br><span class="line">                               	hiTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                            </span><br><span class="line">                        &#125; </span><br><span class="line">                        <span class="comment">//如果e不为空，证明没有到链表尾部，继续执行循环</span></span><br><span class="line">                        <span class="keyword">while</span> ((e = next) != <span class="literal">null</span>);</span><br><span class="line">                        <span class="comment">//低位尾如果记录的有数据，是链表</span></span><br><span class="line">                        <span class="keyword">if</span> (loTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                            <span class="comment">//将下一个元素置空</span></span><br><span class="line">                            loTail.next = <span class="literal">null</span>;</span><br><span class="line">                            <span class="comment">//将低位头放入新数组的原下标位置</span></span><br><span class="line">                            newTab[j] = loHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//高位尾如果记录的有数据，是链表</span></span><br><span class="line">                        <span class="keyword">if</span> (hiTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                            <span class="comment">//将下一个元素置空</span></span><br><span class="line">                            hiTail.next = <span class="literal">null</span>;</span><br><span class="line">                            <span class="comment">//将高位头放入新数组的(原下标+原数组容量)位置</span></span><br><span class="line">                            newTab[j + oldCap] = hiHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="comment">//返回新的数组对象</span></span><br><span class="line">        <span class="keyword">return</span> newTab;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>在添加元素或初始化的时候需要调用resize方法进行扩容，第一次添加数据初始化数组长度为16，以后每次每次扩容都是达到了扩容阈值（数组长度 * 0.75）</p>
</li>
<li><p>每次扩容的时候，都是扩容之前容量的2倍； </p>
</li>
<li><p>扩容之后，会新创建一个数组，需要把老数组中的数据挪动到新的数组中</p>
<ul>
<li>没有hash冲突的节点，则直接使用 e.hash &amp; (newCap - 1) 计算新数组的索引位置</li>
<li>如果是红黑树，走红黑树的添加</li>
<li>如果是链表，则需要遍历链表，可能需要拆分链表，判断(e.hash &amp; oldCap)是否为0，该元素的位置要么停留在原始位置，要么移动到原始位置+增加的数组大小这个位置上</li>
</ul>
</li>
</ul>
<h3 id="3-6-面试题-hashMap的寻址算法"><a href="#3-6-面试题-hashMap的寻址算法" class="headerlink" title="3.6 面试题-hashMap的寻址算法"></a>3.6 面试题-hashMap的寻址算法</h3><p><img src="/img/loading.gif" data-original="/Java%E9%9B%86%E5%90%88%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20230428212501408.png" alt="image-20230428212501408"></p>
<p>在putVal方法中，有一个hash(key)方法，这个方法就是来去计算key的hash值的，看下面的代码</p>
<p><img src="/img/loading.gif" data-original="/Java%E9%9B%86%E5%90%88%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20230428212601977.png" alt="image-20230428212601977"></p>
<p>首先获取key的hashCode值，然后右移16位 异或运算 原来的hashCode值，主要作用就是使原来的hash值更加均匀，减少hash冲突</p>
<p>有了hash值之后，就很方便的去计算当前key的在数组中存储的下标，看下面的代码：</p>
<p><img src="/img/loading.gif" data-original="/Java%E9%9B%86%E5%90%88%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20230428212729580.png" alt="image-20230428212729580"></p>
<p>(n-1)&amp;hash : 得到数组中的索引，代替取模，性能更好，数组长度必须是2的n次幂</p>
<p><strong>关于hash值的其他面试题：为何HashMap的数组长度一定是2的次幂？</strong></p>
<ol>
<li><p>计算索引时效率更高：如果是 2 的 n 次幂可以使用位与运算代替取模</p>
</li>
<li><p>扩容时重新计算索引效率更高： hash &amp; oldCap &#x3D;&#x3D; 0 的元素留在原来位置 ，否则新位置 &#x3D; 旧位置 + oldCap</p>
</li>
</ol>
<h3 id="3-7-面试题-hashmap在1-7情况下的多线程死循环问题"><a href="#3-7-面试题-hashmap在1-7情况下的多线程死循环问题" class="headerlink" title="3.7 面试题-hashmap在1.7情况下的多线程死循环问题"></a>3.7 面试题-hashmap在1.7情况下的多线程死循环问题</h3><p>jdk7的的数据结构是：数组+链表</p>
<p>在数组进行扩容的时候，因为链表是头插法，在进行数据迁移的过程中，有可能导致死循环</p>
<p><img src="/img/loading.gif" data-original="/Java%E9%9B%86%E5%90%88%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20230428213115071.png" alt="image-20230428213115071"></p>
<ul>
<li><p>变量e指向的是需要迁移的对象</p>
</li>
<li><p>变量next指向的是下一个需要迁移的对象</p>
</li>
<li><p>Jdk1.7中的链表采用的头插法</p>
</li>
<li><p>在数据迁移的过程中并没有新的对象产生，只是改变了对象的引用</p>
</li>
</ul>
<p>产生死循环的过程：</p>
<p>线程1和线程2的变量e和next都引用了这个两个节点</p>
<p><img src="/img/loading.gif" data-original="/Java%E9%9B%86%E5%90%88%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20230428213533483.png" alt="image-20230428213533483"></p>
<p>线程2扩容后，由于头插法，链表顺序颠倒，但是线程1的临时变量e和next还引用了这两个节点</p>
<p><img src="/img/loading.gif" data-original="/Java%E9%9B%86%E5%90%88%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20230428214732877.png" alt="image-20230428214732877"></p>
<p>第一次循环</p>
<p>由于线程2迁移的时候，已经把B的next执行了A</p>
<p><img src="/img/loading.gif" data-original="/Java%E9%9B%86%E5%90%88%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20230428214806072.png" alt="image-20230428214806072"></p>
<p>第二次循环</p>
<p><img src="/img/loading.gif" data-original="/Java%E9%9B%86%E5%90%88%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20230428214908652.png" alt="image-20230428214908652"></p>
<p>第三次循环</p>
<p><img src="/img/loading.gif" data-original="/Java%E9%9B%86%E5%90%88%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20230428214937231.png" alt="image-20230428214937231"></p>
<p>参考回答：</p>
<p>在jdk1.7的hashmap中在数组进行扩容的时候，因为链表是头插法，在进行数据迁移的过程中，有可能导致死循环</p>
<p>比如说，现在有两个线程</p>
<p>线程一：读取到当前的hashmap数据，数据中一个链表，在准备扩容时，线程二介入</p>
<p>线程二：也读取hashmap，直接进行扩容。因为是头插法，链表的顺序会进行颠倒过来。比如原来的顺序是AB，扩容后的顺序是BA，线程二执行结束。</p>
<p>线程一：继续执行的时候就会出现死循环的问题。</p>
<p>线程一先将A移入新的链表，再将B插入到链头，由于另外一个线程的原因，B的next指向了A，</p>
<p>所以B-&gt;A-&gt;B,形成循环。</p>
<p>当然，JDK 8 将扩容算法做了调整，不再将元素加入链表头（而是保持与扩容前一样的顺序），<strong>尾插法</strong>，就避免了jdk7中死循环的问题。</p>
<h3 id="3-8-面试题-HashSet与HashMap的区别"><a href="#3-8-面试题-HashSet与HashMap的区别" class="headerlink" title="3.8 面试题-HashSet与HashMap的区别"></a>3.8 面试题-HashSet与HashMap的区别</h3><p>(1)HashSet实现了Set接口, 仅存储对象; HashMap实现了 Map接口, 存储的是键值对.</p>
<p>(2)HashSet底层其实是用HashMap实现存储的, HashSet封装了一系列HashMap的方法. 依靠HashMap来存储元素值,(利用hashMap的key键进行存储), 而value值默认为Object对象. 所以HashSet也不允许出现重复值, 判断标准和HashMap判断标准相同, 两个元素的hashCode相等并且通过equals()方法返回true.</p>
<p><img src="/img/loading.gif" data-original="/Java%E9%9B%86%E5%90%88%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20221007110404375.png" alt="image-20221007110404375"></p>
<h3 id="3-9-面试题-HashTable与HashMap的区别"><a href="#3-9-面试题-HashTable与HashMap的区别" class="headerlink" title="3.9 面试题-HashTable与HashMap的区别"></a>3.9 面试题-HashTable与HashMap的区别</h3><blockquote>
<p>难易程度：☆☆</p>
<p>出现频率：☆☆</p>
</blockquote>
<p>主要区别：</p>
<table>
<thead>
<tr>
<th><strong>区别</strong></th>
<th><strong>HashTable</strong></th>
<th><strong>HashMap</strong></th>
</tr>
</thead>
<tbody><tr>
<td>数据结构</td>
<td>数组+链表</td>
<td>数组+链表+红黑树</td>
</tr>
<tr>
<td>是否可以为null</td>
<td>Key和value都不能为null</td>
<td>可以为null</td>
</tr>
<tr>
<td>hash算法</td>
<td>key的hashCode()</td>
<td>二次hash</td>
</tr>
<tr>
<td>扩容方式</td>
<td>当前容量翻倍 +1</td>
<td>当前容量翻倍</td>
</tr>
<tr>
<td>线程安全</td>
<td>同步(synchronized)的，线程安全</td>
<td>非线程安全</td>
</tr>
</tbody></table>
<p>在实际开中不建议使用HashTable，在多线程环境下可以使用ConcurrentHashMap类</p>
<h2 id="3-真实面试还原"><a href="#3-真实面试还原" class="headerlink" title="3 真实面试还原"></a>3 真实面试还原</h2><h3 id="3-1-Java常见的集合类"><a href="#3-1-Java常见的集合类" class="headerlink" title="3.1 Java常见的集合类"></a>3.1 Java常见的集合类</h3><blockquote>
<p><strong>面试官</strong>：说一说Java提供的常见集合？（画一下集合结构图）</p>
<p><strong>候选人</strong>：</p>
<p>嗯~~，好的。</p>
<p>在java中提供了量大类的集合框架，主要分为两类：</p>
<p>第一个是Collection  属于单列集合，第二个是Map  属于双列集合</p>
<ul>
<li>在Collection中有两个子接口List和Set。在我们平常开发的过程中用的比较多像list接口中的实现类ArrarList和LinkedList。  在Set接口中有实现类HashSet和TreeSet。</li>
<li>在map接口中有很多的实现类，平时比较常见的是HashMap、TreeMap，还有一个线程安全的map:ConcurrentHashMap</li>
</ul>
</blockquote>
<h3 id="3-2-List"><a href="#3-2-List" class="headerlink" title="3.2 List"></a>3.2 List</h3><blockquote>
<p><strong>面试官</strong>：ArrayList底层是如何实现的？</p>
<p><strong>候选人</strong>：</p>
<p>嗯~，我阅读过arraylist的源码，我主要说一下add方法吧</p>
<p>第一：确保数组已使用长度（size）加1之后足够存下下一个数据 </p>
<p>第二：计算数组的容量，如果当前数组已使用长度+1后的大于当前的数组长度，则调用grow方法扩容（原来的1.5倍）</p>
<p>第三：确保新增的数据有地方存储之后，则将新元素添加到位于size的位置上。 </p>
<p>第四：返回添加成功布尔值。 </p>
<p><strong>面试官</strong>：ArrayList list&#x3D;new ArrayList(10)中的list扩容几次</p>
<p><strong>候选人</strong>：</p>
<p>​	是new了一个ArrarList并且给了一个构造参数10，对吧？(问题一定要问清楚再答)</p>
<p><strong>面试官</strong>：是的</p>
<p><strong>候选人</strong>：</p>
<p>​    好的，在ArrayList的源码中提供了一个带参数的构造方法，这个参数就是指定的集合初始长度，所以给了一个10的参数，就是指定了集合的初始长度是10，这里面并没有扩容。</p>
<hr>
<p><strong>面试官</strong>：如何实现数组和List之间的转换</p>
<p><strong>候选人</strong>：</p>
<p>​	嗯，这个在我们平时开发很常见</p>
<p>​    数组转list，可以使用jdk自动的一个工具类Arrars，里面有一个asList方法可以转换为数组</p>
<p>​    List 转数组，可以直接调用list中的toArray方法，需要给一个参数，指定数组的类型，需要指定数组的长度。</p>
<p><strong>面试官</strong>：用Arrays.asList转List后，如果修改了数组内容，list受影响吗？List用toArray转数组后，如果修改了List内容，数组受影响吗</p>
<p><strong>候选人</strong>：</p>
<p>Arrays.asList转换list之后，如果修改了数组的内容，list会受影响，因为它的底层使用的Arrays类中的一个内部类ArrayList来构造的集合，在这个集合的构造器中，把我们传入的这个集合进行了包装而已，最终指向的都是同一个内存地址</p>
<p>list用了toArray转数组后，如果修改了list内容，数组不会影响，当调用了toArray以后，在底层是它是进行了数组的拷贝，跟原来的元素就没啥关系了，所以即使list修改了以后，数组也不受影响</p>
<hr>
<p><strong>面试官</strong>：ArrayList 和 LinkedList 的区别是什么？</p>
<p><strong>候选人</strong>：</p>
<p>嗯，它们两个主要是底层使用的数据结构不一样，ArrayList 是动态数组，LinkedList 是双向链表，这也导致了它们很多不同的特点。</p>
<p>1，从操作数据效率来说</p>
<p>ArrayList按照下标查询的时间复杂度O(1)【内存是连续的，根据寻址公式】， LinkedList不支持下标查询</p>
<p>查找（未知索引）： ArrayList需要遍历，链表也需要链表，时间复杂度都是O(n)</p>
<p>新增和删除</p>
<ul>
<li>ArrayList尾部插入和删除，时间复杂度是O(1)；其他部分增删需要挪动数组，时间复杂度是O(n)</li>
<li>LinkedList头尾节点增删时间复杂度是O(1)，其他都需要遍历链表，时间复杂度是O(n)</li>
</ul>
<p>2，从内存空间占用来说</p>
<p>ArrayList底层是数组，内存连续，节省内存</p>
<p>LinkedList 是双向链表需要存储数据，和两个指针，更占用内存</p>
<p>3，从线程安全来说，ArrayList和LinkedList都不是线程安全的</p>
<p><strong>面试官</strong>：嗯，好的，刚才你说了ArrayList 和 LinkedList 不是线程安全的，你们在项目中是如何解决这个的线程安全问题的？</p>
<p><strong>候选人</strong>：</p>
<p>嗯，是这样的，主要有两种解决方案：</p>
<p>第一：我们使用这个集合，优先在方法内使用，定义为局部变量，这样的话，就不会出现线程安全问题。</p>
<p>第二：如果非要在成员变量中使用的话，可以使用线程安全的集合来替代</p>
<p>ArrayList可以通过Collections 的 synchronizedList 方法将 ArrayList 转换成线程安全的容器后再使用。</p>
<p>LinkedList 换成ConcurrentLinkedQueue来使用·</p>
</blockquote>
<h3 id="3-4-HashMap"><a href="#3-4-HashMap" class="headerlink" title="3.4 HashMap"></a>3.4 HashMap</h3><blockquote>
<p><strong>面试官</strong>：说一下HashMap的实现原理？</p>
<p><strong>候选人</strong>：</p>
<p>​	嗯。它主要分为了一下几个部分：</p>
<p>1，底层使用hash表数据结构，即数组+（链表 | 红黑树）</p>
<p>2，添加数据时，计算key的值确定元素在数组中的下标</p>
<p>​	key相同则替换</p>
<p>​	不同则存入链表或红黑树中</p>
<p>3，获取数据通过key的hash计算数组下标获取元素</p>
<p><strong>面试官</strong>：HashMap的jdk1.7和jdk1.8有什么区别</p>
<p><strong>候选人</strong>：</p>
<ul>
<li><p>JDK1.8之前采用的拉链法，数组+链表</p>
</li>
<li><p>JDK1.8之后采用数组+链表+红黑树，链表长度大于8且数组长度大于64则会从链表转化为红黑树</p>
</li>
</ul>
<p><strong>面试官</strong>：好的，你能说下HashMap的put方法的具体流程吗？</p>
<p><strong>候选人</strong>：</p>
<p>嗯好的。</p>
<ol>
<li><p>判断键值对数组table是否为空或为null，否则执行resize()进行扩容（初始化）</p>
</li>
<li><p>根据键值key计算hash值得到数组索引</p>
</li>
<li><p>判断table[i]&#x3D;&#x3D;null，条件成立，直接新建节点添加</p>
</li>
<li><p>如果table[i]&#x3D;&#x3D;null ,不成立</p>
</li>
</ol>
<p> 4.1 判断table[i]的首个元素是否和key一样，如果相同直接覆盖value</p>
<p> 4.2 判断table[i] 是否为treeNode，即table[i] 是否是红黑树，如果是红黑树，则直接在树中插入键值对</p>
<p> 4.3 遍历table[i]，链表的尾部插入数据，然后判断链表长度是否大于8，大于8的话把链表转换为红黑树，在红黑树中执行插入操 作，遍历过程中若发现key已经存在直接覆盖value</p>
<ol start="5">
<li>插入成功后，判断实际存在的键值对数量size是否超多了最大容量threshold（数组长度*0.75），如果超过，进行扩容。</li>
</ol>
<p><strong>面试官</strong>：好的，刚才你多次介绍了hsahmap的扩容，能讲一讲HashMap的扩容机制吗？</p>
<p><strong>候选人</strong>：</p>
<p>好的</p>
<ul>
<li><p>在添加元素或初始化的时候需要调用resize方法进行扩容，第一次添加数据初始化数组长度为16，以后每次每次扩容都是达到了扩容阈值（数组长度 * 0.75）</p>
</li>
<li><p>每次扩容的时候，都是扩容之前容量的2倍； </p>
</li>
<li><p>扩容之后，会新创建一个数组，需要把老数组中的数据挪动到新的数组中</p>
</li>
<li><p>没有hash冲突的节点，则直接使用 e.hash &amp; (newCap - 1) 计算新数组的索引位置</p>
</li>
<li><p>如果是红黑树，走红黑树的添加</p>
</li>
<li><p>如果是链表，则需要遍历链表，可能需要拆分链表，判断(e.hash &amp; oldCap)是否为0，该元素的位置要么停留在原始位置，要么移动到原始位置+增加的数组大小这个位置上</p>
</li>
</ul>
<p><strong>面试官</strong>：好的，刚才你说的通过hash计算后找到数组的下标，是如何找到的呢，你了解hashMap的寻址算法吗？</p>
<p><strong>候选人</strong>：</p>
<p>这个哈希方法首先计算出key的hashCode值，然后通过这个hash值右移16位后的二进制进行按位<strong>异或运算</strong>得到最后的hash值。</p>
<p>在putValue的方法中，计算数组下标的时候使用hash值与数组长度取模得到存储数据下标的位置，hashmap为了性能更好，并没有直接采用取模的方式，而是使用了数组长度-1 得到一个值，用这个值按位与运算hash值，最终得到数组的位置。</p>
<p><strong>面试官</strong>：为何HashMap的数组长度一定是2的次幂？</p>
<p><strong>候选人</strong>：</p>
<p>嗯，好的。hashmap这么设计主要有两个原因：</p>
<p>第一：</p>
<p>计算索引时效率更高：如果是 2 的 n 次幂可以使用位与运算代替取模</p>
<p>第二：</p>
<p>扩容时重新计算索引效率更高：在进行扩容是会进行判断 hash值按位与运算旧数组长租是否 &#x3D;&#x3D; 0 </p>
<p>如果等于0，则把元素留在原来位置 ，否则新位置是等于旧位置的下标+旧数组长度</p>
<p><strong>面试官</strong>：好的，我看你对hashmap了解的挺深入的，你知道hashmap在1.7情况下的多线程死循环问题吗？</p>
<p><strong>候选人</strong>：</p>
<p>嗯，知道的。是这样</p>
<p>jdk7的的数据结构是：数组+链表</p>
<p>在数组进行扩容的时候，因为链表是<strong>头插法</strong>，在进行数据迁移的过程中，有可能导致死循环</p>
<p>比如说，现在有两个线程</p>
<p>线程一：<strong>读取</strong>到当前的hashmap数据，数据中一个链表，在准备扩容时，线程二介入</p>
<p>线程二也读取hashmap，直接进行扩容。因为是头插法，链表的顺序会进行颠倒过来。比如原来的顺序是AB，扩容后的顺序是BA，线程二执行结束。</p>
<p>当线程一再继续执行的时候就会出现死循环的问题。</p>
<p>线程一先将A移入新的链表，再将B插入到链头，由于另外一个线程的原因，B的next指向了A，所以B-&gt;A-&gt;B,形成循环。</p>
<p>当然，JDK 8 将扩容算法做了调整，不再将元素加入链表头（而是保持与扩容前一样的顺序），<strong>尾插法</strong>，就避免了jdk7中死循环的问题。</p>
<p><strong>面试官</strong>：好的，hashmap是线程安全的吗？</p>
<p><strong>候选人</strong>：不是线程安全的</p>
<p><strong>面试官</strong>：那我们想要使用线程安全的map该怎么做呢？</p>
<p><strong>候选人</strong>：我们可以采用ConcurrentHashMap进行使用，它是一个线程安全的HashMap</p>
<p><strong>面试官</strong>：那你能聊一下ConcurrentHashMap的原理吗？</p>
<p><strong>候选人</strong>：好的，请参考《多线程相关面试题》中的ConcurrentHashMap部分的讲解</p>
<hr>
<p><strong>面试官</strong>：HashSet与HashMap的区别？</p>
<p><strong>候选人</strong>：嗯，是这样。</p>
<p>HashSet底层其实是用HashMap实现存储的, HashSet封装了一系列HashMap的方法. 依靠HashMap来存储元素值,(利用hashMap的key键进行存储), 而value值默认为Object对象. 所以HashSet也不允许出现重复值, 判断标准和HashMap判断标准相同, 两个元素的hashCode相等并且通过equals()方法返回true.</p>
<p><strong>面试官</strong>：HashTable与HashMap的区别</p>
<p><strong>候选人</strong>：</p>
<p>嗯，他们的主要区别是有几个吧</p>
<p>第一，数据结构不一样，hashtable是数组+链表，hashmap在1.8之后改为了数组+链表+红黑树</p>
<p>第二，hashtable存储数据的时候都不能为null，而hashmap是可以的</p>
<p>第三，hash算法不同，hashtable是用本地修饰的hashcode值，而hashmap经常了二次hash</p>
<p>第四，扩容方式不同，hashtable是当前容量翻倍+1，hashmap是当前容量翻倍</p>
<p>第五，hashtable是线程安全的，操作数据的时候加了锁synchronized，hashmap不是线程安全的，效率更高一些</p>
<p>在实际开中不建议使用HashTable，在多线程环境下可以使用ConcurrentHashMap类</p>
</blockquote>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">我在守着黎明</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2023/11/02/Java%E9%9B%86%E5%90%88%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/">http://example.com/2023/11/02/Java%E9%9B%86%E5%90%88%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">wt小屋</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E9%9B%86%E5%90%88/">集合</a></div><div class="post_share"><div class="social-share" data-image="/img/avatar.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赞助</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/avatar.jpg" target="_blank"><img class="post-qr-code-img" src="/img/loading.gif" data-original="/img/avatar.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/tag_img.jpg" target="_blank"><img class="post-qr-code-img" src="/img/loading.gif" data-original="/img/tag_img.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2023/10/26/hello-world/" title="Hello World"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Hello World</div></div></a></div></nav><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div><div class="comment-switch"><span class="first-comment">Valine</span><span id="switch-btn"></span><span class="second-comment">Disqus</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div><div><div id="disqus_thread"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/loading.gif" data-original="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">我在守着黎明</div><div class="author-info__description">我是宇宙无敌大统领！！！</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">2</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">1</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="tencent://AddContact/?fromId=45&amp;fromSubId=1&amp;subcmd=all&amp;uin=728831102&amp;website=www.oicqzone.com" target="_blank" title="QQ"><i class="fab fa-qq"></i></a><a class="social-icon" href="mailto:2367548296@qq.com" target="_blank" title="Email"><i class="fas fa-envelope-open-text"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><div class="content"><a class="title" href="/2023/11/02/Java%E9%9B%86%E5%90%88%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/" title="Java集合相关面试题">Java集合相关面试题</a><time datetime="2023-11-02T09:04:00.000Z" title="发表于 2023-11-02 17:04:00">2023-11-02</time></div></div><div class="aside-list-item"><div class="content"><a class="title" href="/2023/10/26/hello-world/" title="Hello World">Hello World</a><time datetime="2023-10-26T03:55:01.755Z" title="发表于 2023-10-26 11:55:01">2023-10-26</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By 我在守着黎明</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>(() => {
  const initValine = () => {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: '',
      appKey: '',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  const loadValine = async () => {
    if (typeof Valine === 'function') initValine()
    else {
      await getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js')
      initValine()
    }
  }

  if ('Valine' === 'Valine' || !false) {
    if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
    else setTimeout(loadValine, 0)
  } else {
    window.loadOtherComment = loadValine
  }
})()</script><script>(() => {
  const disqus_config = function () {
    this.page.url = 'http://example.com/2023/11/02/Java%E9%9B%86%E5%90%88%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/'
    this.page.identifier = '/2023/11/02/Java%E9%9B%86%E5%90%88%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/'
    this.page.title = 'Java集合相关面试题'
  }

  const disqusReset = () => {
    window.DISQUS && window.DISQUS.reset({
      reload: true,
      config: disqus_config
    })
  }

  btf.addGlobalFn('themeChange', disqusReset, 'disqus')

  const loadDisqus = () =>{
    if (window.DISQUS) disqusReset()
    else {
      const script = document.createElement('script')
      script.src = 'https://.disqus.com/embed.js'
      script.setAttribute('data-timestamp', +new Date())
      document.head.appendChild(script)
    }
  }

  const getCount = async() => {
    try {
      const eleGroup = document.querySelector('#post-meta .disqus-comment-count')
      if (!eleGroup) return
      const cleanedLinks = eleGroup.href.replace(/#post-comment$/, '')

      const res = await fetch(`https://disqus.com/api/3.0/threads/set.json?forum=&api_key=&thread:link=${cleanedLinks}`,{
        method: 'GET'
      })
      const result = await res.json()

      const count = result.response.length ? result.response[0].posts : 0
      eleGroup.textContent = count
    } catch (err) {
      console.error(err)
    }
  }

  if ('Valine' === 'Disqus' || !false) {
    if (false) btf.loadComment(document.getElementById('disqus_thread'), loadDisqus)
    else {
      loadDisqus()
      
    }
  } else {
    window.loadOtherComment = loadDisqus
  }
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div>
        <style>
            [bg-lazy] {
                background-image: none !important;
                background-color: #eee !important;
            }
        </style>
        <script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                preloadRatio: 1,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})});</script><script>!function(r){r.imageLazyLoadSetting.processImages=t;var e=r.imageLazyLoadSetting.isSPA,n=r.imageLazyLoadSetting.preloadRatio||1,c=a();function a(){var t=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")),e=Array.prototype.slice.call(document.querySelectorAll("[bg-lazy]"));return t.concat(e)}function t(){e&&(c=a());for(var t,o=0;o<c.length;o++)0<=(t=(t=c[o]).getBoundingClientRect()).bottom&&0<=t.left&&t.top<=(r.innerHeight*n||document.documentElement.clientHeight*n)&&function(){var t,e,n,a,i=c[o];e=function(){c=c.filter(function(t){return i!==t}),r.imageLazyLoadSetting.onImageLoaded&&r.imageLazyLoadSetting.onImageLoaded(i)},(t=i).hasAttribute("bg-lazy")?(t.removeAttribute("bg-lazy"),e&&e()):(n=new Image,a=t.getAttribute("data-original"),n.onload=function(){t.src=a,t.removeAttribute("data-original"),e&&e()},t.src!==a&&(n.src=a))}()}function i(){clearTimeout(t.tId),t.tId=setTimeout(t,500)}t(),document.addEventListener("scroll",i),r.addEventListener("resize",i),r.addEventListener("orientationchange",i)}(this);</script></body></html>